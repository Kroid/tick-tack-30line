//Переменная t выполяет роль поля, которое состоит из 9 клеток
var t = []; //создается массив длинной 9 элементов, все элементы имеют значение undefined, хотя как показывает console.log, данный массив не содержит ни одного элемента
//todo если все заработает, заменить массив созданный с помощью прототипа Array, на массив созданный с помощью литеральной нотации, или убрать его вовсе. Судя по всему созданный таким образом массив, содержит элементы с порядковым номером начиная от 0 и заканчивая 8, это объяснило бы метод выбранный для генерации случайного числа в функции ai.

function ai() {
    var id = Math.floor(Math.random() * 9); //Math.floor() возвращает самое большое целое число, которое меньше или равно аргументу. Math.random() возвращает случайное число в диапозоне от 0 до 1 вида 0.527798029826954, при этом число с плавующей запятой. Возвращает значения [0,1) что означает, что 0 может быть выведен, а 1 нет.
    t[id]? ai() : move(id, 'ai'); //Выбирает случайный элемент из массива. Если элемент уже существует(не равен undefined), то применяется рекурсия, и происходит повторный вызов фукнции ai, в противном случае, происходит вызов функции move, с передачей ей 2 аргументов: текущего случайно сгенерированного значение
// todo которое в крайне редких случаях может быть равно 9, если вообще может, и строку ai, которая определяет роль игрока.
}

//Эта функция проверяет массив на заполненность, применяя логику правил крестики-нолики, она не проверяет кто победил, только оповещает о том что игра оконченна, если кто-то заполнил определенным образом элементы массива, или, просто, все элементы заполены.
function checkEnd() {
    if (t[0]=='ai' && t[1]=='ai' && t[2]=='ai' || t[0]=='player' && t[1]=='player' && t[2]=='player')  return true;
    if (t[3]=='ai' && t[4]=='ai' && t[5]=='ai' || t[3]=='player' && t[4]=='player' && t[5]=='player')  return true;
    if (t[6]=='ai' && t[7]=='ai' && t[8]=='ai' || t[6]=='player' && t[7]=='player' && t[8]=='player')  return true;
    if (t[0]=='ai' && t[3]=='ai' && t[6]=='ai' || t[0]=='player' && t[3]=='player' && t[6]=='player')  return true;
    if (t[1]=='ai' && t[4]=='ai' && t[7]=='ai' || t[1]=='player' && t[4]=='player' && t[7]=='player')  return true;
    if (t[2]=='ai' && t[5]=='ai' && t[8]=='ai' || t[2]=='player' && t[5]=='player' && t[8]=='player')  return true;
    if (t[0]=='ai' && t[4]=='ai' && t[8]=='ai' || t[0]=='player' && t[4]=='player' && t[8]=='player')  return true;
    if (t[2]=='ai' && t[4]=='ai' && t[6]=='ai' || t[2]=='player' && t[4]=='player' && t[6]=='player')  return true;
    if(t[0] && t[1] && t[2] && t[3] && t[4] && t[5] && t[6] && t[7] && t[8]) return true;
}

function move(id, role) {
    if (t[id]) return false; //Данная инструкция дает возможность произвести проверку хода пользователя, так как проверка случайно сгенерированного хода компьютера осуществлялась в функции ai. Если пользователь нажмет на ячейку, которой уже присвоенно значение в элементе массива, то никаких дальнейших действий не последует.
    t[id] = role; //Производится присваивания значение элементу массива, который ранее не был записан, для последующего запуска функции checkEnd и проверки на основании присвоенных значений, окончание партии.
    document.getElementById('a' + id).className = 'cell ' + role;//В данному случае происходил заполнение ячейки, путем присваивания, класса, ячейке с полученным id(стоит отметить, что id ячейки, в силу того, что используется для записи значения в элемент массива, является цифра, а использование цифр в начале имени ID - запрещенно.)
    !checkEnd() ? (role == 'player') ? ai() : null : reset();//Сама по себе функция преобразованная в boolean - это undefined, что является false, соответственно обратное - true, но если функция явно вернет true, то будет false. Читается как, если игра не закончилась, и если ход произвел игрок, то тогда запускаем функцию ai(ответный ход), если же ход произвел ai, то ничего не происходит. Если же checkEnd() вернул true, то запускается функция reset.
    console.log(t[0] + t[1]);
}

function reset() {
    alert("Игра окончена!");
    location.reload();//Делает тоже самое, что и кнопка перезагрузки страницы в браузере.
}























//for(var m in t) {
//    console.log(t[m]);
//    console.log(1);
//} for in в отличии от foreach as в PHP перебирает и массив, и св-во объекта. Не считает за элементы массивы массива, элементы со значением undefined, и даже не запускает цикл когда их обнаруживает.